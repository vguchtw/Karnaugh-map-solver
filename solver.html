
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Karnaugh Map Solver — Standalone Demo</title>
  <meta name="description" content="Interactive Karnaugh Map (K‑map) solver with 2–6 variables, Gray code mapping, and Quine–McCluskey simplification.">
  <meta name="robots" content="index,follow">

  <style>
    :root{
      --bg: #0f172a;
      --panel: #111827;
      --card: #ffffff;
      --text: #0b1220;
      --accent: #2563eb;
      --muted: #6b7280;
      --ring: rgba(37, 99, 235, .35);
    }
    @media (prefers-color-scheme: dark) {
      :root{
        --bg: #0b1220;
        --panel: #0f172a;
        --card: #111827;
        --text: #e5e7eb;
        --accent: #60a5fa;
        --muted: #9ca3af;
        --ring: rgba(96, 165, 250, .35);
      }
    }
    * { box-sizing: border-box }
    html, body { height: 100% }
    body{
      margin:0;
      background: radial-gradient(1200px 600px at 10% -10%, rgba(96,165,250,.08), transparent 60%),
                  radial-gradient(1200px 600px at 110% 10%, rgba(34,197,94,.06), transparent 60%),
                  var(--bg);
      color: var(--text);
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    .wrap{ max-width: 1100px; margin: 0 auto; padding: 24px; }

    header.site{
      display:flex; align-items:center; justify-content:space-between;
      gap: 12px; padding: 14px 0 22px;
    }
    .brand{ display:flex; align-items:center; gap:12px; }
    .logo{
      width:38px; height:38px; border-radius:10px;
      display:grid; place-items:center;
      background: linear-gradient(135deg, rgba(37,99,235,.25), rgba(99,102,241,.25));
      border: 1px solid rgba(148,163,184,.2);
      box-shadow: 0 6px 30px rgba(37,99,235,.15), inset 0 0 0 1px rgba(255,255,255,.05);
      color:#fff; font-weight:800;
    }

    .title{
      font-size: clamp(20px, 2.5vw, 28px);
      font-weight: 800; letter-spacing:.2px;
      color: var(--muted);
    }
    .subtitle{
      color: var(--muted);
      font-size: 14px;
      margin-top: 2px;
    }

    .hero{
      margin: 6px 0 20px;
      padding: 18px 18px;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
      border: 1px solid rgba(148,163,184,.25);
    }
    .hero p{ margin: 0.4rem 0; color: var(--muted) }

    .card{
      background: var(--card);
      color: var(--text);
      border-radius: 14px;
      padding: 18px;
      border: 1px solid rgba(148,163,184,.35);
      box-shadow: 0 20px 60px rgba(2,6,23,.25);
    }

    .note{ font-size: 13px; color: var(--muted); margin-top: 8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="site">
      <div class="brand">
        <div class="logo">K</div>
        <div>
          <div class="title">Karnaugh Map Solver</div>
        </div>
      </div>
    </header>

    <section class="hero card">
      <p>Click cells to toggle 0/1. Use the selector to choose the number of variables (2–8). The simplified expression updates instantly.</p>
    </section>

    <section class="card" aria-label="Karnaugh Map Solver">
      <div class="karnaugh-solver">
        <style>
          .karnaugh-solver { font-family: Arial, sans-serif; margin: 20px; }
          .karnaugh-solver .instructions { font-size: 16px; margin-bottom: 20px; }
          .karnaugh-solver .settings { margin-bottom: 20px; text-align: center; }
          .karnaugh-solver .settings select { font-size: 16px; padding: 5px; width: auto; max-width: 100px; }
          .karnaugh-solver table { width: 100%; max-width: 600px; margin: 0 auto; border-collapse: collapse; }
          .karnaugh-solver td {
            width: 40px; height: 40px; text-align: center; vertical-align: middle;
            border: 1px solid #333; font-size: 18px; user-select: none; cursor: pointer;
          }
          .karnaugh-solver td.active { background-color: #aaf; }
          .karnaugh-solver .result-area { text-align: center; font-weight: bold; margin-top: 20px; }
          .karnaugh-solver .mobile-fallback {
            display: none; padding: 20px; background: #fee; text-align: center; font-size: 16px; border: 1px solid #f00;
          }
          @media (max-width: 767px) {
            .karnaugh-solver > *:not(.mobile-fallback) { display: none; }
            .karnaugh-solver .mobile-fallback { display: block; }
          }
          /* new small tweaks */
          .karnaugh-solver .settings .row { display:flex; gap: 10px; justify-content:center; flex-wrap: wrap; align-items:center; }
          .karnaugh-solver .settings label { color: var(--muted); font-size: 14px; margin-right: 6px; }
          .karnaugh-solver .settings .group { display:flex; align-items:center; gap: 6px; }
          .karnaugh-solver .output-area { margin-top: 16px; }
          .karnaugh-solver #diagram-container { display:none; margin-top: 12px; }
          .karnaugh-solver #code-container { display:none; margin-top: 12px; }
          .karnaugh-solver pre { background: #0f172a; color: #e5e7eb; padding: 12px; border-radius: 8px; overflow:auto; }
        </style>

        <div class="instructions">
          Tap a cell to toggle between 0 and 1; the simplified expression updates automatically.
        </div>

        <div class="settings">
          <div class="row">
            <div class="group">
              <label for="var-count">Variables</label>
              <select id="var-count">
                <option value="2">2×2</option>
                <option value="3">2×4</option>
                <option value="4" selected>4×4</option>
                <option value="5">4×8</option>
                <option value="6">8×8</option>
              </select>
            </div>
            <div class="group">
              <label for="method">Form</label>
              <select id="method">
                <option value="SOP" selected>Σ (SOP)</option>
                <option value="POS">Π (POS)</option>
              </select>
            </div>
            <div class="group">
              <label for="output-type">Output</label>
              <select id="output-type">
                <option value="text" selected>Text</option>
                <option value="diagram">Logic gates (diagram)</option>
                <option value="pseudocode">Python pseudocode</option>
              </select>
            </div>
          </div>
        </div>

        <div id="kmap-container"></div>

        <div class="output-area">
          <div class="result-area" id="result">Simplified expression will appear here.</div>
          <div id="diagram-container"></div>
          <div id="code-container"><pre id="code-output"></pre></div>
        </div>

        <div class="mobile-fallback">
          This Karnaugh Map Solver requires a screen at least 768px wide. Please switch to a larger device or rotate your screen.
        </div>

        <script>
          (function(){
            let numVars = 4;
            let method = 'SOP';
            let outputType = 'text';
            let kmap = [];
            let rowCodes = [];
            let colCodes = [];

            function grayCode(n) {
              if (n === 0) return [''];
              const prev = grayCode(n - 1);
              return prev.map(c => '0' + c).concat(prev.slice().reverse().map(c => '1' + c));
            }

            function generateMap() {
              const rows = Math.pow(2, Math.floor(numVars / 2));
              const cols = Math.pow(2, Math.ceil(numVars / 2));
              rowCodes = grayCode(Math.floor(numVars / 2));
              colCodes = grayCode(Math.ceil(numVars / 2));

              kmap = Array.from({ length: rows }, () => Array(cols).fill(0));
              const table = document.createElement('table');
              for (let r = 0; r < rows; r++) {
                const tr = document.createElement('tr');
                for (let c = 0; c < cols; c++) {
                  const td = document.createElement('td');
                  td.textContent = '0';
                  td.addEventListener('click', () => {
                    kmap[r][c] ^= 1;
                    td.textContent = kmap[r][c];
                    td.classList.toggle('active', kmap[r][c] === 1);
                    solve();
                  });
                  tr.appendChild(td);
                }
                table.appendChild(tr);
              }
              const container = document.getElementById('kmap-container');
              container.innerHTML = '';
              container.appendChild(table);
            }

            function getBinary(num, len) {
              let s = num.toString(2);
              return '0'.repeat(len - s.length) + s;
            }
            function combineTerms(a, b) {
              let diff = 0, out = '';
              for (let i = 0; i < a.length; i++) {
                if (a[i] === b[i]) out += a[i];
                else { if (a[i] === '-' || b[i] === '-') return null; diff++; out += '-'; }
              }
              return diff === 1 ? out : null;
            }
            function findPrimeImplicants(minterms, vars) {
              let terms = minterms.map(m => ({ term: getBinary(m, vars), minterms: [m], used: false }));
              let primes = [];
              while (terms.length) {
                const next = [];
                terms.forEach((t, i) => terms.slice(i+1).forEach(u => {
                  const c = combineTerms(t.term, u.term);
                  if (c) {
                    t.used = u.used = true;
                    if (!next.some(x => x.term === c)) next.push({ term: c, minterms: [...new Set([...t.minterms, ...u.minterms])], used: false });
                  }
                }));
                terms.forEach(t => { if (!t.used) primes.push(t); });
                terms = next;
              }
              return primes;
            }
            function selectPrimeImplicants(primes, minterms) {
              const chart = {};
              minterms.forEach(m => chart[m] = primes.reduce((arr,p,i) => p.minterms.includes(m) ? arr.concat(i) : arr, []));
              const essential = new Set(Object.values(chart).filter(c => c.length === 1).map(c => c[0]));
              let covered = new Set(); essential.forEach(i => primes[i].minterms.forEach(m => covered.add(m)));
              let selected = [...essential]; let rem = minterms.filter(m => !covered.has(m));
              while (rem.length) {
                let best = -1, bestCount = 0;
                primes.forEach((p,i) => {
                  if (selected.includes(i)) return;
                  const count = p.minterms.filter(m => rem.includes(m)).length;
                  if (count > bestCount) { bestCount = count; best = i; }
                });
                if (best < 0) break;
                selected.push(best);
                primes[best].minterms.forEach(m => covered.add(m));
                rem = minterms.filter(m => !covered.has(m));
              }
              return selected.map(i => primes[i]);
            }
            function termToExpr(term) {
              const vars = ['A','B','C','D','E','F'];
              return term.split('').map((b,i) => b === '1' ? vars[i] : b === '0' ? vars[i] + "'" : '').join('') || '1';
            }
            function termToLiteralsSOP(term) {
              const vars = ['A','B','C','D','E','F'];
              const out = [];
              term.split('').forEach((b,i) => {
                if (b === '-') return;
                out.push({ variable: vars[i], negated: b === '0' });
              });
              return out;
            }
            function termToClauseStringPOSFromComplementTerm(term) {
              const vars = ['A','B','C','D','E','F'];
              // For F' term bit: 1 -> A in product => in F clause becomes A' ; 0 -> A' in product => in F clause becomes A
              const lits = [];
              term.split('').forEach((b,i) => {
                if (b === '-') return;
                lits.push(b === '1' ? vars[i] + "'" : vars[i]);
              });
              return lits.join(' + ') || '1';
            }
            function termToClauseLiteralsPOSFromComplementTerm(term) {
              const vars = ['A','B','C','D','E','F'];
              const out = [];
              term.split('').forEach((b,i) => {
                if (b === '-') return;
                out.push({ variable: vars[i], negated: b === '1' });
              });
              return out;
            }

            function computeSOP(minterms) {
              const total = Math.pow(2, numVars);
              if (!minterms.length) return { type: 'const', value: '0', terms: [] };
              if (minterms.length === total) return { type: 'const', value: '1', terms: [] };
              const primes = findPrimeImplicants(minterms, numVars);
              const sel = selectPrimeImplicants(primes, minterms);
              const terms = sel.map(p => p.term);
              const expr = terms.map(t => termToExpr(t)).join(' + ');
              return { type: 'expr', value: expr, terms };
            }

            function computePOS(minterms) {
              const total = Math.pow(2, numVars);
              const mintermSet = new Set(minterms);
              const zeros = [];
              for (let i = 0; i < total; i++) if (!mintermSet.has(i)) zeros.push(i);
              if (zeros.length === 0) return { type: 'const', value: '1', clauses: [] };
              if (zeros.length === total) return { type: 'const', value: '0', clauses: [] };
              const primes = findPrimeImplicants(zeros, numVars); // compute for F'
              const sel = selectPrimeImplicants(primes, zeros);
              const terms = sel.map(p => p.term);
              const clauses = terms.map(t => '(' + termToClauseStringPOSFromComplementTerm(t) + ')');
              const expr = clauses.join(' · ');
              return { type: 'expr', value: expr, terms };
            }

            function renderExpressionText(text) {
              const resultEl = document.getElementById('result');
              resultEl.textContent = 'Simplified Expression: ' + text;
            }

            function renderLogicDiagram(kind, terms) {
              const container = document.getElementById('diagram-container');
              if (!terms || !terms.length) {
                container.innerHTML = '';
                return;
              }
              const gateLabel = kind === 'SOP' ? 'AND' : 'OR';
              const finalLabel = kind === 'SOP' ? 'OR' : 'AND';
              const width = 700;
              const termCount = terms.length;
              const rowH = 70;
              const gateW = 80;
              const gateH = 40;
              const margin = 20;
              const leftX = 60;
              const rightX = width - gateW - 60;
              const midY = margin + termCount * rowH / 2;
              const height = margin * 2 + termCount * rowH;

              let svg = '';
              svg += `<svg viewBox="0 0 ${width} ${height}" width="100%" height="${height}" xmlns="http://www.w3.org/2000/svg" style="max-width: 760px; border:1px solid rgba(148,163,184,.35); border-radius: 8px; background: rgba(255,255,255,.04)">`;

              for (let i = 0; i < termCount; i++) {
                const y = margin + i * rowH + (rowH - gateH) / 2;
                // input stub
                svg += `<line x1="${leftX - 40}" y1="${y + gateH/2}" x2="${leftX}" y2="${y + gateH/2}" stroke="#94a3b8" stroke-width="2"/>`;
                // term box
                svg += `<rect x="${leftX}" y="${y}" width="${gateW}" height="${gateH}" rx="8" ry="8" fill="#111827" stroke="#94a3b8"/>`;
                svg += `<text x="${leftX + gateW/2}" y="${y + gateH/2 + 5}" font-size="14" fill="#e5e7eb" text-anchor="middle" font-family="monospace">${gateLabel}</text>`;
                // wire to final
                svg += `<line x1="${leftX + gateW}" y1="${y + gateH/2}" x2="${rightX}" y2="${y + gateH/2}" stroke="#94a3b8" stroke-width="2"/>`;
                // annotate literals
                let litText = '';
                if (kind === 'SOP') {
                  litText = termToLiteralsSOP(terms[i]).map(l => l.negated ? l.variable + "'" : l.variable).join(' ');
                } else {
                  litText = termToClauseLiteralsPOSFromComplementTerm(terms[i]).map(l => l.negated ? l.variable + "'" : l.variable).join(' + ');
                  litText = '(' + litText + ')';
                }
                svg += `<text x="${leftX + gateW/2}" y="${y - 6}" font-size="12" fill="#9ca3af" text-anchor="middle" font-family="monospace">${litText || (kind==='SOP'?'1':'(1)')}</text>`;
              }

              // final gate
              const finalY = midY - gateH / 2;
              svg += `<rect x="${rightX}" y="${finalY}" width="${gateW}" height="${gateH}" rx="8" ry="8" fill="#111827" stroke="#94a3b8"/>`;
              svg += `<text x="${rightX + gateW/2}" y="${finalY + gateH/2 + 5}" font-size="14" fill="#e5e7eb" text-anchor="middle" font-family="monospace">${finalLabel}</text>`;
              // output wire
              svg += `<line x1="${rightX + gateW}" y1="${midY}" x2="${rightX + gateW + 60}" y2="${midY}" stroke="#94a3b8" stroke-width="2"/>`;
              svg += `<text x="${rightX + gateW + 70}" y="${midY + 5}" font-size="14" fill="#e5e7eb" font-family="monospace">F</text>`;

              svg += `</svg>`;
              container.innerHTML = svg;
            }

            function renderPythonPseudocode(kind, terms) {
              const codeEl = document.getElementById('code-output');
              const vars = ['A','B','C','D','E','F'].slice(0, numVars);
              let code = '';
              if (!terms || terms.length === 0) {
                // constant handled outside
                codeEl.textContent = '';
                return;
              }
              code += `def f(${vars.join(', ')}):\n`;
              if (kind === 'SOP') {
                const parts = terms.map(t => {
                  const lits = termToLiteralsSOP(t).map(l => l.negated ? `not ${l.variable}` : l.variable);
                  return '(' + (lits.join(' and ') || 'True') + ')';
                });
                code += `    return ${parts.join(' or ')}\n`;
              } else { // POS
                const parts = terms.map(t => {
                  const lits = termToClauseLiteralsPOSFromComplementTerm(t).map(l => l.negated ? `${l.variable}` + "'" : l.variable);
                  // For Python, use not for negation
                  const pyLits = termToClauseLiteralsPOSFromComplementTerm(t).map(l => l.negated ? `not ${l.variable}` : l.variable);
                  return '(' + (pyLits.join(' or ') || 'True') + ')';
                });
                code += `    return ${parts.join(' and ')}\n`;
              }
              codeEl.textContent = code;
            }

            function solve() {
              const minterms = [];
              for (let r = 0; r < rowCodes.length; r++) {
                for (let c = 0; c < colCodes.length; c++) {
                  if (kmap[r][c]) {
                    const bits = rowCodes[r] + colCodes[c];
                    minterms.push(parseInt(bits, 2));
                  }
                }
              }

              let resultObj;
              if (method === 'SOP') resultObj = computeSOP(minterms);
              else resultObj = computePOS(minterms);

              const resultEl = document.getElementById('result');
              const diagramEl = document.getElementById('diagram-container');
              const codeWrapEl = document.getElementById('code-container');

              // toggle displays
              resultEl.style.display = (outputType === 'text') ? 'block' : 'none';
              diagramEl.style.display = (outputType === 'diagram') ? 'block' : 'none';
              codeWrapEl.style.display = (outputType === 'pseudocode') ? 'block' : 'none';

              if (resultObj.type === 'const') {
                const constText = resultObj.value;
                renderExpressionText(constText);
                if (outputType === 'diagram') {
                  // draw a simple constant output
                  const container = document.getElementById('diagram-container');
                  container.innerHTML = `<svg viewBox="0 0 300 80" width="100%" height="80" xmlns="http://www.w3.org/2000/svg" style="max-width: 760px; border:1px solid rgba(148,163,184,.35); border-radius: 8px; background: rgba(255,255,255,.04)">
                    <text x="20" y="45" font-size="16" fill="#e5e7eb" font-family="monospace">F = ${constText}</text>
                  </svg>`;
                } else if (outputType === 'pseudocode') {
                  const vars = ['A','B','C','D','E','F'].slice(0, numVars);
                  const code = `def f(${vars.join(', ')}):\n    return ${constText === '1' ? 'True' : 'False'}\n`;
                  document.getElementById('code-output').textContent = code;
                }
                return;
              }

              // expression text
              renderExpressionText(resultObj.value);

              // diagram
              if (outputType === 'diagram') {
                renderLogicDiagram(method, resultObj.terms);
              }

              // pseudocode
              if (outputType === 'pseudocode') {
                renderPythonPseudocode(method, resultObj.terms);
              }
            }

            document.getElementById('var-count').addEventListener('change', e => {
              numVars = parseInt(e.target.value, 10);
              generateMap();
              solve();
            });
            document.getElementById('method').addEventListener('change', e => {
              method = e.target.value;
              solve();
            });
            document.getElementById('output-type').addEventListener('change', e => {
              outputType = e.target.value;
              solve();
            });

            generateMap();
            solve();
          })();
        </script>
      </div>
    </section>

  </div>
</body>
</html>